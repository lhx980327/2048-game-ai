typedef int board_t[SIZE][SIZE];
struct hash_elem {
    int hash;
    int depth;
    double value;
};
 
enum input {
    LEFT = 0,
    RIGHT = 1,
    UP = 2,
    DOWN = 3,
    QUIT = 4
};
 

 
void init() {
    int i;
    int cur_weight = 1; #set up the current score
    int cur_real = 2;
    for (i = 1; i < 16; i++) {
        value_weight[i] = cur_weight;
        value_real[i] = cur_real;
        cur_weight *= 3;
        cur_real *= 2;
    }
}
 
/* Util Functions *****************************************************/
long gettime() {
    struct timeval tv;
    gettimeofday(&tv, NULL);
    return tv.tv_sec * 1000 * 1000 + tv.tv_usec;
}
 
void draw_grid(int y, int x) {
    mvprintw(y++, x,    "#####################################");
    mvprintw(y++, x,    "#        |        |        |        #");
    mvprintw(y++, x,    "#        |        |        |        #");
    mvprintw(y++, x,    "#        |        |        |        #");
    mvprintw(y++, x,    "#-----------------------------------#");
    mvprintw(y++, x,    "#        |        |        |        #");
    mvprintw(y++, x,    "#        |        |        |        #");
    mvprintw(y++, x,    "#        |        |        |        #");
    mvprintw(y++, x,    "#-----------------------------------#");
    mvprintw(y++, x,    "#        |        |        |        #");
    mvprintw(y++, x,    "#        |        |        |        #");
    mvprintw(y++, x,    "#        |        |        |        #");
    mvprintw(y++, x,    "#-----------------------------------#");
    mvprintw(y++, x,    "#        |        |        |        #");
    mvprintw(y++, x,    "#        |        |        |        #");
    mvprintw(y++, x,    "#        |        |        |        #");
    mvprintw(y++, x,    "#####################################");
    mvprintw(y+2, x,    "Control: WASD  Exit: Esc");
}
 
 
void board_dump(board_t b, int y, int x) { 
    int i, j;
    draw_grid(y, x);
    for (i = 0; i < SIZE; i++) {
        for (j = 0; j < SIZE; j++) {
            if (b[i][j])
                mvprintw(i * 4 + 2 + y, j * 9 + 3 + x, "%d", value_real[b[i][j]]);
        }
    }
}
 
int board_count_zero(board_t b) {
    int count = 0;
    int i, j;
    for (i = 0; i < SIZE; i++) {
        for (j = 0; j < SIZE; j++) {
            if (b[i][j] == 0)
                count++;
        }
    }
    return count;
}
 
void board_clear(board_t b) {
    int i, j;
    for (i = 0; i < SIZE; i++) {
        for (j = 0; j < SIZE; j++) {
            b[i][j] = 0;
        }
    }
}
 
int board_hash(board_t b) {
    int i, j;
    int hash = 0;
    for (i = 0; i < SIZE; i++) {
        for (j = 0; j < SIZE; j++) {
            hash += b[i][j];
        }
    }
    return hash;
}
 

 
void delay() {
    struct timespec t;
    t.tv_sec = 0;
    t.tv_nsec = 10000000;
    nanosleep(&t, NULL);
}
 
/* Performance statistic */
long stat_time[16];
long stat_count[16]; 
void stat(int depth, long time) {
    stat_count[depth]++;
    stat_time[depth] += time;
}
 
void stat_dump() {
    int i;
    int line = 0;
    mvprintw(25 + line++, 8, "Performance Stat");
    for (i = 0; i < 16; i++) {
        if (!stat_count[i])
            continue;
        mvprintw(25 + line++, 8, "[Depth %d] %ld us * %d times",
            i, stat_time[i] / stat_count[i], stat_count[i]);
    }   
}
 
/* Game logic: Move to a direction **************************************************/
 
/* Return score earned, return 1 if moved with zero score */
#define movefunc(src_cell, combine_cell, nocombine_cell)\
{\
    int i, j = 0;\
    int moved = 0;\
    int score = 0;\
    for (i = 0; i < SIZE; i++) {\
        int last = 0;\
        int j2 = 0;\
        for (j = 0; j < SIZE; j++) {\
            int v = src_cell;\
            if (v == 0) {\
                continue;\
            }\
            if (v == last) {\
                last = 0;\
                combine_cell = v + 1;\
                score += value_real[v + 1];\
            } else {\
                if (j2 < j)\
                    moved = 1;\
                last = v;\
                nocombine_cell = v;\
                j2++;\
            }\
        }\
    }\
    return score ? score : moved;\
}
 
#define REVERSE(i) (SIZE - 1 - (i))
 
 
 
int move_left(board_t src, board_t dst) {
    movefunc(src[i][j], dst[i][j2 - 1], dst[i][j2]);
}
 
int move_right(board_t src, board_t dst) {
    movefunc(src[i][REVERSE(j)], dst[i][REVERSE(j2 - 1)], dst[i][REVERSE(j2)]);
}
 
int move_up(board_t src, board_t dst) {
    movefunc(src[j][i], dst[j2 - 1][i], dst[j2][i]);
}
 
int move_down(board_t src, board_t dst) {
    movefunc(src[REVERSE(j)][i], dst[REVERSE(j2 - 1)][i], dst[REVERSE(j2)][i]);
}
 
 
/* AI-related functions **************************************************/
double value(board_t b, int depth, int *choice, double max);
 
/* Immediate value score estimation for a board */
int imm_value(board_t b) {
    int i, j;
    int result = 0;
 
    for (i = 0; i < SIZE; i++) {
        for (j = 0; j < SIZE; j++) {
            result += value_weight[b[i][j]] * cell_weight[i][j];
        }
    }
    return result;
}
 
